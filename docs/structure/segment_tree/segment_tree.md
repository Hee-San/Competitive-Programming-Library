## 概要

Segment Tree / セグメント木 (monoids, 完全二分木, 一点更新, 区間取得)

- Monoidは、結合則を満たす二項演算と単位元を持つ集合。非可換でもOK
- 更新時に区間の演算結果を更新する

## 説明

ある配列があるとき、値の更新と、区間に対するクエリを高速に処理するデータ構造。

- 完全二分木を用いて、各ノードに区間の演算結果を持つ
- 葉において値の更新が行われると、その値を持つノードから根に向かって、$O(\log n)$ 個のノードの値を更新する
- 区間に対するクエリは、その区間を覆うような、$O(\log n)$ 個のノードが持つ演算結果をマージすることで求めることができる

例えば、区間の和を求める場合を考える。

初期に与えた配列が `[10, 20, 30, 40, 50]` の場合、セグメント木は以下のようになる。
一番下の段には、元の配列の値が格納され、それ以外のノードには、その区間の和をあらかじめ計算して格納しておく。

``` bash
  0: |                    150|
  1: |        100|         50|
  2: |   30|   70|   50|    0|
  3: |10|20|30|40|50| 0| 0| 0|
```

※ 完全二分木のため、葉の数が $2^k$ になるようにダミーの要素を追加している</br>
※ 実装では簡単のために、1-indexed で管理している。150という値は、木を管理する配列`tree`の`tree[1]`に格納されている

ここで、区間 `[1, 5)` の和を求める場合、もとの二分木のうち、以下のノードに着目する。</br>
※ 区間`[1, 5)`は、配列で言うと `[20, 30, 40, 50]` に対応する

``` bash
  0: |                       |
  1: |           |           |
  2: |     |   70|     |     |
  3: |  |20|30|40|50|  |  |  |
```

愚直に計算すると、`20 + 30 + 40 + 50 = 140` となるが、この方法では区間の長さに比例して計算量が増えてしまう。

すでに `30 + 40 = 70` という計算結果が2段目のノードに格納されているため、これを利用して計算することで、`20 + 70 + 50 = 140` という結果を得ることができる。
このように、適切なノードの値を利用することで、計算量を削減することができる。
具体的には、区間の長さが `n` の場合、計算量は $O(\log n)$ になる。

次に、配列の要素 `40` を `45` に更新する場合を考える。
ここで、この更新によって影響を受けるノードは以下の通り。

``` bash
  0: |                    155|
  1: |        105|           |
  2: |     |   75|     |     |
  3: |  |  |  |45|  |  |  |  |
```

このように、更新されたノードから根に向かって、$O(\log n)$ 個のノードの値を更新することで、セグメント木を更新することができる。

本コードでは、値の型や演算を抽象化するために、Monoidというクラスを用意している。
Monoidは、結合則を満たす二項演算と単位元を持つ集合であり、それを継承したクラスを定義することで、任意の型に対してセグメント木を構築することができる。

上の例では、整数の和を考えているので、次のようなモノイドでセグメント木を構築する。

``` cpp
struct plus_monoid : public Monoid<ll> { // 値の型をll (long long int) とする
public:
    ll unit() override { return 0; } // 足し算なので、単位元は0
    ll mult(const ll& a, const ll& b) override { return a + b; } // 足し算
};
```

このようにして定義したモノイドを用いて、セグメント木を構築することができる。

### References

- セグメント木とは: [プログラミングコンテストでのデータ構造](https://www.slideshare.net/iwiwi/ss-3578491)
- 基本的な実装: [セグメント木をソラで書きたいあなたに](https://tsutaj.hatenablog.com/entry/2017/03/29/204841)
- 非再帰・1-indexed・非2冪: [非再帰セグ木サイコー！ 一番すきなセグ木です](https://hcpc-hokudai.github.io/archive/structure_segtree_001.pdf)
- 蟻本 p.153
- かつっぱさんの動画: [木マスター養成講座](https://www.youtube.com/watch?v=LjhVy1ZJTMc&list=PL3Hpv03CoZ24p5a6qT0LsFKEhiDWxf_B_&index=3)

## 使い方

### 初期化

- `n` 要素の配列を持つセグメント木を初期化する

``` cpp
segment_tree<plus_monoid<ll>> seg(n);
rep(i, n) seg.point_set(i, v[i]);

// または
rep(i, n) seg.unsafe_set(i, v[i]);
seg.build();
```

- 配列 `v` で初期化する

``` cpp
segment_tree<plus_monoid<ll>> seg(v);
```

- monoid を定義する

``` cpp
struct ll_plus_monoid : public Monoid<ll> {
public:
    ll unit() override { return 0; }
    ll mult(const ll& a, const ll& b) override { return a + b; }
};

void main(){
  // ...
  segment_tree<ll_plus_monoid> seg(v);
  // ...
}
```

### 更新

- `i` 番目の要素を `x` に更新する
- $O(\log n)$

``` cpp
seg.point_set(i, x);
```

### 区間取得

- `[l, r)` の区間の演算結果を取得する
- $O(\log n)$

``` cpp
seg.fold(l, r);
```

### 可視化（デバッグ用）

``` cpp
seg.visualize_for_debug();
```

``` bash
 0: |                    343|
 1: |        189|        154|
 2: |  140|   49|   91|   63|
 3: |60|80|24|25|19|72|25|38|
```
